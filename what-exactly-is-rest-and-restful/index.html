<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="HandheldFriendly" content="True">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="referrer" content="no-referrer-when-downgrade">

        <title>REST 以及 RESTful 辨析</title>
        <meta name="description" content="">

        <link rel="stylesheet" href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;main.css">

        
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.zongwu233.com/rss.xml">
        

        
        
        
        
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-68155231-1"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-68155231-1');
        </script>
        
    </head>
    <body>

      <a class="skip-main" href="#main">Skip to content</a>
        <div class="container">
            <header> 
                <h1 class="site-header">
                    <a href="https:&#x2F;&#x2F;blog.zongwu233.com">zongwu&#x27;s blog</a>
                </h1>
                <nav>
                    
                    
                    
                    <a  href="https:&#x2F;&#x2F;blog.zongwu233.com">Home</a>
                    
                    
                    <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;categories&#x2F;">Categories</a>
                    
                    
                    <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;tags&#x2F;">Tags</a>
                    
                    
                    <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;about&#x2F;">About</a>
                    
                    
                    <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;rss.xml">RSS</a>
                    
                    
                </nav>
            </header>
            <main id="main" tabindex="-1">
                

<article class="post">
    <header>
        <h1>REST 以及 RESTful 辨析</h1>
    </header>
    <div class="content">
        <p>从<code>REST</code>概念提出到现在已经20年了，业界的主流实践采纳借鉴了其部分原则，但与其最核心的架构设计渐行渐远。</p>
<p>实际上那个去中心化的、面向全世界开放的万维网时代正在落幕，构建在其基础之上的<code>REST</code>架构思想，也无可避免地被冷落或者被误解。</p>
<span id="continue-reading"></span><h2 id="ding-yi">定义</h2>
<p><code>REST</code>全称是<code>Representational State Transfer</code>。翻译过来是表述性状态转移。字面意思很晦涩。</p>
<p><code>REST</code>是web服务的一种软件架构风格。</p>
<p><code>Roy Thomas Fielding</code>博士于2000年在他的论文中提出的概念。他将<code>REST</code>定位为&quot;分布式超媒体应用（Distributed Hypermedia System）&quot;的架构风格。符合<code>REST</code>风格的架构都可以称作是<code>RESTful</code>的。</p>
<p>在当时，主流的web服务架构是<code>SOAP</code>和<code>XML-RPC</code>。</p>
<p>想要理解<code>REST</code>就要深入理解其涉及到的几个核心概念以及原则（或者叫约束）。</p>
<h2 id="he-xin-gai-nian">核心概念：</h2>
<h3 id="resource">Resource</h3>
<p>资源，是对信息的关键性抽象，任何可以命名的信息都可以定义为资源。通过URI标识，实际使用中通过URL获取。</p>
<h3 id="representational">Representational</h3>
<p>资源的表述，比如<code>HTML</code>，<code>JSON</code> ，<code>XML</code>，<code>JPEG</code>等等。HTTP协议中定义了媒体类型，比如<code>text/html</code>， <code>image/jpeg</code>、<code>application/json</code>、<code>text/xml</code>等。</p>
<h3 id="state-transfer">State Transfer</h3>
<p>状态转移，这里指应用的状态转移，不是资源的状态。</p>
<p>用户在操作页面的时候，从他的角度看，他改变了应用程序的状态。使用表述的超媒体（HTML就是一种超媒体）来表示和管理应用程序状态的方式，称为：以超媒体作为应用程序状态引擎（ <code>hypermedia as the engine of application state</code> ）或者简称为超文本约束( <code>hypertet constraint</code> )。</p>
<h2 id="restjia-gou-feng-ge-jia-gou-yue-shu">REST架构风格架构约束</h2>
<p>REST架构风格最重要的架构约束有6个：</p>
<h3 id="1-client-server-architecture">1. Client-server architecture</h3>
<p>C/S架构，该原则的主要目的是将服务端和客户端的关注点分离。</p>
<h3 id="2-stateless">2. Stateless</h3>
<p>无状态，服务端不保存客户端的上下文信息。每一次客户端发起请求，都要包含必须的所有状态信息。</p>
<h3 id="3-cacheability">3. Cacheability</h3>
<p>缓存。如同万维网一样, 客户端和中间通讯传递者可以将响应缓存起来。 </p>
<h3 id="4-layered-system">4. Layered System</h3>
<p>分层系统。客户端通常无法确定它是直接连接到最终服务器还是中间连接。在客户端和服务器之间放置代理或负载平衡器，则不会影响它们之间的通信，也不需要更新客户端或服务器代码。</p>
<h3 id="5-code-on-demand-optional">5. Code-On-Demand（optional）</h3>
<p>按需代码(可选的)。服务器可以通过传输可执行代码来临时扩展或定制客户端的功能：例如，诸如Java applet之类的已编译组件，或诸如JavaScript之类的客户端脚本。</p>
<h3 id="6-uniform-interface">6. Uniform Interface</h3>
<p>统一接口。该约束原则是一切RESTful 系统设计的基础，它简化和分离了架构，使每个部分都可以独立发展。此统一接口的四个约束是：</p>
<h5 id="6-1-resource-identification-in-requests-qing-qiu-zhong-de-zi-yuan-shi-bie">6.1 Resource identification in requests（请求中的资源识别）</h5>
<p>在请求中标识各个资源，例如使用RESTful Web服务中的URI。资源本身在概念上与返回给客户端的表示形式是分开的。例如，服务器可以从数据库中以HTML，XML或JSON格式发送数据，这些都不是服务器的内部表示形式。</p>
<h5 id="6-2-resource-manipulation-through-representations-tong-guo-biao-shi-lai-cao-zong-zi-yuan">6.2 Resource manipulation through representations（通过表示来操纵资源）</h5>
<p>当客户端持有资源的表示形式（包括附加的任何元数据）时，它具有足够的信息来修改或删除资源的状态。</p>
<h5 id="6-3-self-descriptive-messages-zi-wo-miao-shu-de-xiao-xi">6.3 Self-descriptive messages（自我描述的消息）</h5>
<p>每个消息都包含足够的信息来描述如何处理该消息。例如，可以通过媒体类型指定要调用的解析器。</p>
<h5 id="6-4-hypermedia-as-the-engine-of-application-state-hateoas-chao-mei-ti-zuo-wei-ying-yong-cheng-xu-zhuang-tai-yin-qing">6.4 Hypermedia as the engine of application state（ HATEOAS，超媒体作为应用程序状态引擎）</h5>
<p>访问了REST应用程序的初始URI（类似于访问网站首页的人类Web用户），REST客户端随后应能够动态使用服务器提供的链接来发现其所需的所有可用资源。随着访问的进行，服务器将以文本作为响应，该文本包括指向当前可用其他资源的超链接。不需要使用有关应用程序的结构或动态的信息对客户端进行硬编码。</p>
<h2 id="qi-ta">其他</h2>
<p>遵循以上6个约束原则的架构设计都是<code>RESTful</code>架构。</p>
<p>我们目前大多数人使用的<code>RESTful API</code>，都是一种混合了<code>SOA</code>架构的，或者直接就是以RPC思维定义出来的API风格。也难怪很多人会误以为<code>RESTful API</code>就是采用<code>JSON</code>格式、使用<code>HTTP</code>的<code>GET/POST/PUT/DELETE</code>方法对应查询/新增/修改/删除来操作数据。</p>
<p>这里存在几个误区，第一点，比较初级的错误，很多<code>API</code>的<code>url</code>里面带有动词，比如 <code>/user/modify-avator</code>，<code>/user/comment/canel</code> 这种定义方式实际上是想使用<code>RPC</code>，将<code>HTTP</code>退化成一种传输协议，那就不如直接基于<code>TCP</code>。</p>
<p>第二点，以为<code>RESTful</code>就是赋予<code>HTTP</code>的<code>verb</code>更为清晰的动作含义。比如<code>POST</code>是新增数，<code>PUT</code>就是修改。对照上面的6点原则，完全没有提到对资源修改的动作标准。实际上，<code>REST</code>从没有提及在任何情况该使用哪种<code>HTTP method</code>的建议。约束原则只强调接口统一，即便使用<code>POST</code>来更新数据，而不是像大多数人推荐的使用<code>PUT</code>，这一点也不违反<code>REST</code>。使用真正的<code>RESTful API</code>，除了初始的<code>URI</code>和一组标准化媒体类型（比如<code>HTML</code>），不需要其他先验知识。因为所有的应用程序状态的转换，必须是由客户端选择服务器提供的选项来驱动。</p>
<p>第三点，以为使用了<code>HTTP</code>不同的<code>verb</code>修改资源，就是在做资源的状态转移。这一点的迷惑性很大，只有理解了<code>HATEOAS</code>，才会明白<code>REST</code>中的状态转移是指应用的状态，而且是基于用户点击/操作了不同的超链接，使得应用展现不同的资源，从而进入了不同的状态。跟操作变更具体的资源完全不是同一个概念。</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">2020-12-09</div>
        
        <div class="article-taxonomies">
            
                <ul class="article-categories">
                    
                    <li><a href="https://blog.zongwu233.com/categories/blog/">blog</a></li>
                    
                </ul>
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://blog.zongwu233.com/tags/rest/">#REST</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/restful/">#RESTful</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/webfu-wu-jia-gou/">#web服务架构</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/jia-gou-feng-ge/">#架构风格</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/api/">#API</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


            </main>
            <footer>
                <p>
                © zongwu&#x27;s blog 2015 - 2022<br>
                </p>
                <p>
                
                
                </p>
            </footer>
        </div>
</body>
</html>
