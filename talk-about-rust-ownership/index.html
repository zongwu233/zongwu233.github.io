<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>让我们聊一聊Rust的所有权系统</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;main.css">

    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.zongwu233.com/rss.xml">
    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;blog.zongwu233.com">zongwu&#x27;s blog</a>
            </h1>
            <nav>
                
                
                
                <a  href="https:&#x2F;&#x2F;blog.zongwu233.com">Home</a>
                
                
                <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;categories&#x2F;">Categories</a>
                
                
                <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;tags&#x2F;">Tags</a>
                
                
                <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;about&#x2F;">About</a>
                
                
                <a  href="https:&#x2F;&#x2F;blog.zongwu233.com&#x2F;rss.xml">RSS</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>让我们聊一聊Rust的所有权系统</h1>
    </header>
    <div class="content">
        <p>所有权（ownership）系统是 Rust 最与众不同的特性，让Rust实现了<strong>既要</strong>保障内存安全<strong>又要</strong>无GC，运行时高性能的目标。</p>
<span id="continue-reading"></span>
<p>所有的编程语言都需要考虑内存管理机制。</p>
<p>一些语言提供垃圾回收机制（garbage collection,GC），例如：Java、Python、Golang、Lisp、Haskell、JavaScript 等等。
另一些语言需要编程人员手工管理内存，进行分配和释放内存。例如：C、C++。</p>
<p>两种机制各有优势和缺点：</p>
<p>带GC的编程语言，自动管理内存，消除人工管理带来的内存管理安全性问题，降低编程语言学习复杂度和使用复杂度，但是带来了额外的运行时性能开销，无法保证高性能和高实时性。</p>
<p>手工管理内存，运行时高性能， 但是增加编程人员的使用心智负担，容易造成内存管理安全性上的bug。</p>
<p>Rust选择了第三种方式，通过（自己创立的）所有权系统进行内存管理。这也是为什么最近Rust编程语言从一出现就备受瞩目的原因之一。</p>
<p>关于所有权系统，编译器会在<strong>编译期</strong>依据所有权规则对代码进行检查。不会给运行期带来额外的开销。（缺点是编译期阶段的时间变的很长，编译后的代码体积会膨胀（就所有权而言，实际上跟范型化的生命周期标记的实现相关））。</p>
<p>让我们来看看所有权规则：</p>
<h2 id="rust-suo-you-quan-gui-ze-rust-ownership-rules">Rust 所有权规则（Rust ownership rules）</h2>
<blockquote>
<ol>
<li>Each value in Rust has a variable that’s called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
</blockquote>
<p>规则1：Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</p>
<p>规则2：值在任一时刻有且只有一个所有者。</p>
<p>规则3：当所有者（变量）离开作用域，这个值将被丢弃。</p>
<h2 id="nei-cun-guan-li">内存管理</h2>
<p>Rust所有权规则1中的值，要么分配在栈上，要么分配在堆上。栈上的数据会随着入栈出栈操作被自动清理，编程语言主要是对堆进行内存管理。</p>
<h2 id="gui-ze-1yu-gui-ze-2">规则1与规则2</h2>
<p>规则1 理解起来比较简单直观，在 Rust 中通过 <code>let</code> 关键字将一个值绑定到一个变量上。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main </span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">12</span><span style="color:#c0c5ce;">;
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> b = &quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;;
    
    </span><span style="color:#b48ead;">let </span><span style="color:#c0c5ce;">(c,d) = (&quot;</span><span style="color:#a3be8c;">str1</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">str2</span><span style="color:#c0c5ce;">&quot;);
    
    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">,</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">,</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">,</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a ,b ,c ,d)
}
</span></code></pre><h3 id="moveyu-yi">move语义</h3>
<p>如果将一个变量赋值给另外一个变量会如何？考虑下面这种情况：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main </span><span style="color:#c0c5ce;">(){
   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = String::from(&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;);
   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> b = a;
   
   println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
   println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,b);

}
</span></code></pre>
<p>编译会报错：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">error[</span><span style="color:#d08770;">E0382</span><span style="color:#c0c5ce;">]: borrow of moved value: `a`
 --&gt; src/main.rs:</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">:</span><span style="color:#d08770;">18
  </span><span style="color:#c0c5ce;">|
</span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">|    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = String::from(&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;);
  |        - move occurs because `a` has type `String`, which does not implement the `Copy` trait
</span><span style="color:#d08770;">3 </span><span style="color:#c0c5ce;">|    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> b = a;
  |            - value moved here
</span><span style="color:#d08770;">4 </span><span style="color:#c0c5ce;">|    
</span><span style="color:#d08770;">5 </span><span style="color:#c0c5ce;">|    println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
  |                  ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain </span><span style="color:#d08770;">E0382</span><span style="color:#c0c5ce;">`.
</span></code></pre>
<p>直接错误提示是：<code>error[E0382]: borrow of moved value: 'a'</code>借用已经move的值a。</p>
<p>同时在<code>let b = a;</code>那行编译器提示<code>value moved here</code>，在此处值被move了。</p>
<p>我们对<code>let</code> 关键字的理解更加深入：对于形如 <code>let  x  = y;</code> 的语句，如果<code>y</code>是变量，<strong><code>let</code> 会引发变量的所有权转移。</strong></p>
<p>也即是：<strong><code>let</code>操作默认是<code>move</code>语义。</strong> 从而保障了规则2的约束。</p>
<h3 id="copy-trait">Copy trait</h3>
<p>新的问题出现，下面这段代码没有遵循<code>move</code>语义，但编译成功：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main </span><span style="color:#c0c5ce;">(){

   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">128</span><span style="color:#c0c5ce;">;
   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> b = a;</span><span style="color:#65737e;">// move ?
   
   </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);</span><span style="color:#65737e;">//128
   </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,b);</span><span style="color:#65737e;">//128

</span><span style="color:#c0c5ce;">}
</span></code></pre>
<p>那是因为考虑到使用上的便利性，在有些场景下并不希望应用默认的<code>move</code>语义。Rust的基础数据类型都实现了 std::marker::Copy <code>trait</code>，所以在进行<code>let</code>操作时，实际上发生了<code>copy</code>。</p>
<p>哪些类型是满足<code>Copy</code>特性的？类似整型这样的存储在栈上的类型、不需要分配内存或某种形式资源的类型。常见的<code>Copy</code> 类型如下：</p>
<ul>
<li>所有整数类型，比如 u32。</li>
<li>布尔类型，bool，它的值是 true 和 false。</li>
<li>所有浮点数类型，比如 f64。</li>
<li>字符类型，char。</li>
<li>元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。</li>
</ul>
<h3 id="clone-trait">Clone trait</h3>
<p>保留原来的变量，并且将值内容拷贝给新的变量，对简单的数字类型很容易理解接受，那如果是复杂类型或者说是自定义类型呢？
如果不希望发生所有权转移，可以使用<code>clone</code>。如下：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main </span><span style="color:#c0c5ce;">(){

   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = String::from(&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;);
   </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> b = a.</span><span style="color:#96b5b4;">clone</span><span style="color:#c0c5ce;">();
   
   println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
   println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,b);

}
</span></code></pre>
<p><code>String</code>实现了std::clone::Clone <code>trait</code>。使用<code>clone</code>操作后两个变量持有不同的值（这两个值是不同的内存空间）。
能不能像使用基础数据类型那样方便地应用<code>copy</code>语义呢？可以的，如下：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Debug,Copy,Clone)] </span><span style="color:#65737e;">// here！
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Foo {
    </span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">,
    </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i64</span><span style="color:#c0c5ce;">,
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> f1 = Foo { x: </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, y: </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">};
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> f2: Foo = f1;
    println!(&quot;</span><span style="color:#a3be8c;">p1 = </span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;, f1);
    println!(&quot;</span><span style="color:#a3be8c;">p1 = </span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;, f2);

}
</span></code></pre>
<p>当然这里的例子有一点点特殊，<code>Foo</code>结构体的成员都是基础类型，所以我们标记注解<code>#[derive(Debug,Copy,Clone)]</code> 即可满足。
如果其成员是复杂的类型，就需要实现<code>Copy</code>和<code>Clone</code>的<code>trait</code>。</p>
<p>注意：<code>Clone trait</code>是<code>Copy trait</code>的 <code>supertrait</code>，所以任何一个实现<code>Copy</code>的类型必须实现<code>Clone</code>。</p>
<h3 id="suo-you-quan-yu-han-shu">所有权与函数</h3>
<p>调用函数的时候，会将实际参传递给形式参数，这个操作在语义上与给变量赋值相似。可能会移动或者复制，遵循与赋值语句一样的规则。例如：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;);  </span><span style="color:#65737e;">// s 进入作用域

    </span><span style="color:#96b5b4;">takes_ownership</span><span style="color:#c0c5ce;">(s);             </span><span style="color:#65737e;">// s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">;                      </span><span style="color:#65737e;">// x 进入作用域

    </span><span style="color:#96b5b4;">makes_copy</span><span style="color:#c0c5ce;">(x);                  </span><span style="color:#65737e;">// x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

</span><span style="color:#c0c5ce;">} </span><span style="color:#65737e;">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">takes_ownership</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">some_string</span><span style="color:#c0c5ce;">: String) { </span><span style="color:#65737e;">// some_string 进入作用域
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, some_string);
} </span><span style="color:#65737e;">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">makes_copy</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">some_integer</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">) { </span><span style="color:#65737e;">// some_integer 进入作用域
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, some_integer);
} </span><span style="color:#65737e;">// 这里，some_integer 移出作用域。不会有特殊操作
</span></code></pre>
<p>这里没有特殊情况，很好。</p>
<h3 id="yin-yong-yu-jie-yong">引用与借用</h3>
<p>再看如下的代码：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s1 = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#b48ead;">let </span><span style="color:#c0c5ce;">(s2, len) = </span><span style="color:#96b5b4;">calculate_length</span><span style="color:#c0c5ce;">(s1);

    println!(&quot;</span><span style="color:#a3be8c;">The length of &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">.</span><span style="color:#c0c5ce;">&quot;, s2, len);
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">calculate_length</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">s</span><span style="color:#c0c5ce;">: String) -&gt; (String, </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> length = s.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">(); </span><span style="color:#65737e;">// len() 返回字符串的长度

    </span><span style="color:#c0c5ce;">(s, length)
}
</span></code></pre>
<p>在每一次函数调用的时候，都获取所有权，然后在函数调用完成的时候，再返回所有权，这种方式略显繁琐。而这种调用在实际场景中极其常见，Rust提供了引用（references）功能来解决这个问题。</p>
<p>利用引用，上面的代码可以改写成：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s1 = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> len = </span><span style="color:#96b5b4;">calculate_length</span><span style="color:#c0c5ce;">(&amp;s1);

    println!(&quot;</span><span style="color:#a3be8c;">The length of &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">.</span><span style="color:#c0c5ce;">&quot;, s1, len);
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">calculate_length</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">s</span><span style="color:#c0c5ce;">: &amp;String) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
    s.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">()
}
</span></code></pre>
<p>传给<code>calculate_length()</code>的是<code>&amp;s1</code>而不是<code>s1</code>。函数的声明是<code>calculate_length(s: &amp;String)</code>参数是<code>s: &amp;String</code>。</p>
<p><strong><code>&amp;</code>就是引用。它允许你使用值但不获取其所有权。</strong> 毕竟我们需要遵循规则2。</p>
<p><strong>我们把采用引用作为函数参数称为借用（borrowing）</strong> </p>
<p>这里并不想展开讨论不可变引用和可变引用的相关规则，那是并发编程场景下需要关注的点。</p>
<p>关于引用还需要特别注意的一个点是作用域。一个<strong>引用的作用域</strong>从声明的地方开始一直持续到<strong>最后一次使用为止</strong>。如下代码是可以编译的：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> r1 = &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> s; </span><span style="color:#65737e;">// 没问题
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, r1); </span><span style="color:#65737e;">//r1最后使用的地方

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> r2 = &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> s; </span><span style="color:#65737e;">// 没问题
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, r2);
}
</span></code></pre>
<p>编译器负责推断引用最后一次使用的代码位置。</p>
<h3 id="slice">slice</h3>
<p>对集合一段连续元素的引用就是[slice类型]。
例如：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> hello = &amp;s[</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">..</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">];
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> world = &amp;s[</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">..</span><span style="color:#d08770;">11</span><span style="color:#c0c5ce;">];
    
    println!(&quot;</span><span style="color:#d08770;">{} {}</span><span style="color:#c0c5ce;">&quot;,hello,world);
    
}
</span></code></pre>
<p>实际上，字符串字面量就是 <code>slice</code> 。</p>
<p><code>let s = &quot;Hello, world!&quot;;</code></p>
<p>这里的 <code>s</code>的类型是 <code>&amp;str</code>，它是一个指向二进制程序特定位置的 <code>slice</code>。<code>&amp;str</code>是一个不可变引用。</p>
<h2 id="gui-ze-3">规则3</h2>
<p>当所有者（变量）离开作用域，这个值将被丢弃。</p>
<p>如何在合适的时机清理回收内存？当持有堆内存数据的变量离开作用域的时候，堆内存的数据将被<code>drop</code>掉。</p>
<p>编译器会自动插入<code>drop</code>相关的代码，在运行时需要<code>drop</code> 的时候调用。</p>
<p>这条规则的重点就是作用域了。</p>
<h3 id="zuo-yong-yu">作用域</h3>
<p>作用域是一个项（item）在程序中有效的范围。最常见的就是<strong>函数作用域</strong>，比如</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){</span><span style="color:#65737e;">// s无效

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s = &quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;;</span><span style="color:#65737e;">// s进入作用域
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,s);
    
}</span><span style="color:#65737e;">// s离开作用域
</span></code></pre>
<p>还有块作用域，例如：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){</span><span style="color:#65737e;">// s无效

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s = &quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;;</span><span style="color:#65737e;">// s进入作用域
    </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,s);
    {
        </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">; </span><span style="color:#65737e;">//a 进入作用域
         </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
    }</span><span style="color:#65737e;">// a离开作用域
    
    //println!(&quot;{}&quot;,a); 这里会出错
    
</span><span style="color:#c0c5ce;">}</span><span style="color:#65737e;">// s离开作用域
</span></code></pre>
<p>实际上，<code>let</code>关键字会隐式地开启一个作用域，对于以下代码：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){ 

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s1 = &quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;; 
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> s2 =&quot;</span><span style="color:#a3be8c;">world</span><span style="color:#c0c5ce;">&quot;;
    
} 
</span></code></pre>
<p>利用 https://play.rust-lang.org/  的 SHOW MIR 功能可以看到：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() -&gt; () {
    </span><span style="color:#b48ead;">let mut </span><span style="color:#d08770;">_0</span><span style="color:#c0c5ce;">: ();                      </span><span style="color:#65737e;">// return place in scope 0 at src/main.rs:1:10: 1:10
    </span><span style="color:#b48ead;">let </span><span style="color:#d08770;">_1</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">;                        </span><span style="color:#65737e;">// in scope 0 at src/main.rs:3:9: 3:11
</span><span style="color:#c0c5ce;">    scope </span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">{
        debug s1 =&gt; </span><span style="color:#d08770;">_1</span><span style="color:#c0c5ce;">;                  </span><span style="color:#65737e;">// in scope 1 at src/main.rs:3:9: 3:11
        </span><span style="color:#b48ead;">let </span><span style="color:#d08770;">_2</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">;                    </span><span style="color:#65737e;">// in scope 1 at src/main.rs:4:9: 4:11
</span><span style="color:#c0c5ce;">        scope </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">{
            debug s2 =&gt; </span><span style="color:#d08770;">_2</span><span style="color:#c0c5ce;">;              </span><span style="color:#65737e;">// in scope 2 at src/main.rs:4:9: 4:11
        </span><span style="color:#c0c5ce;">}
    }

...
</span></code></pre>
<p><code>main</code>函数的作用域<code>scope 0</code>，在其中，<code>let s1 = &quot;hello&quot;; </code> 创建一个作用域<code>scope 1</code>，然后<code>let s2 =&quot;world&quot;;</code> 又在<code>scope 1</code>里面创建了<code>scope 2</code>。</p>
<p>关于引用的特殊作用域问题，上一小节已经说明，这里不再重复。</p>
<h3 id="bi-bao-dai-lai-de-wen-ti">闭包带来的问题</h3>
<p>闭包（closures）可以从环境捕获变量，并在闭包体中使用。有三种使用变量的方式：获取所有权、可变引用、不可变引用。Rust 提供了3种<code>Fn trait</code> 以便编译器能够更清晰直接地处理不同场景下闭包对变量所有权的操作问题。</p>
<ul>
<li>FnOnce 获取变量所有权，Once表明闭包不能多次获取同一个变量的所有权，所以只能调用一次。</li>
<li>FnMut 获取变量可变的借用值</li>
<li>Fn 获取变量的不可变的借用值</li>
</ul>
<p>注意：<code>FnOnce</code>是<code>FnMut</code> <code>Fn</code>的<code>supertrait</code>；<code>FnMut</code>是<code>Fn</code>的<code>supertrait</code>。
<code>FnOnce</code>的例子：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">do_action</span><span style="color:#c0c5ce;">&lt;F&gt;(</span><span style="color:#bf616a;">func</span><span style="color:#c0c5ce;">:F)</span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> F:FnOnce()-&gt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">{
    println!(&quot;</span><span style="color:#a3be8c;">disappeared variable length : </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">func</span><span style="color:#c0c5ce;">());
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = String::from(&quot;</span><span style="color:#a3be8c;">hello world</span><span style="color:#c0c5ce;">&quot;);
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> useless_warpper = </span><span style="color:#b48ead;">move </span><span style="color:#c0c5ce;">||-&gt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">{a.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">() } ;
    </span><span style="color:#96b5b4;">do_action</span><span style="color:#c0c5ce;">(useless_warpper);
    
    </span><span style="color:#65737e;">//println!(&quot;{}&quot;,a);  //这里再使用a会报错
</span><span style="color:#c0c5ce;">}

</span></code></pre>
<p>使用了一个关键字<code>move</code> 将闭包需要捕获的变量的所有权<code>move</code>到闭包内。
<code>FnMut</code>的例子：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">do_action</span><span style="color:#c0c5ce;">&lt;F&gt;(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">func</span><span style="color:#c0c5ce;">:F)</span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> F:FnMut()-&gt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">{
    println!(&quot;</span><span style="color:#a3be8c;">mutable result </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">func</span><span style="color:#c0c5ce;">());
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">12</span><span style="color:#c0c5ce;">;
    </span><span style="color:#b48ead;">let mut </span><span style="color:#8fa1b3;">mutable_warpper </span><span style="color:#c0c5ce;">= ||-&gt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">{ a+=</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">;a } ;
    </span><span style="color:#96b5b4;">do_action</span><span style="color:#c0c5ce;">(mutable_warpper);
    
    println!(&quot;</span><span style="color:#a3be8c;">now </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
}

</span></code></pre>
<p><code>Fn</code>的例子（将闭包形式简化）：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">do_action</span><span style="color:#c0c5ce;">&lt;F&gt;(</span><span style="color:#bf616a;">func</span><span style="color:#c0c5ce;">:F)</span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;"> F:Fn()-&gt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">{
    println!(&quot;</span><span style="color:#a3be8c;">result </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">func</span><span style="color:#c0c5ce;">());
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> a = </span><span style="color:#d08770;">12</span><span style="color:#c0c5ce;">;
    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">square </span><span style="color:#c0c5ce;">= || a*a ;
    </span><span style="color:#96b5b4;">do_action</span><span style="color:#c0c5ce;">(square);
    
    println!(&quot;</span><span style="color:#a3be8c;">now </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;,a);
}

</span></code></pre><h3 id="yin-yong-de-sheng-ming-zhou-qi-lifetime-biao-ji">引用的生命周期(lifetime)标记</h3>
<p>大部分场景下，我们使用变量的时候，编译器能够自动推断变量的作用域并正常工作。但有时候不那么明显，特别是使用引用的很多场景下，需要手工标记变量的生命周期，帮助编译器检查引用的生命周期不会超过对象的生命周期。
例如：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> r;
    {
        </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">;
        r = &amp;x;
    }
    println!(&quot;</span><span style="color:#a3be8c;">r: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, r);
}
</span></code></pre>
<p>编译失败：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">error[</span><span style="color:#d08770;">E0597</span><span style="color:#c0c5ce;">]: `x` does not live long enough
 --&gt; src/main.rs:</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">:</span><span style="color:#d08770;">13
  </span><span style="color:#c0c5ce;">|
</span><span style="color:#d08770;">5 </span><span style="color:#c0c5ce;">|         r = &amp;x;
  |             ^^ borrowed value does not live long enough
</span><span style="color:#d08770;">6 </span><span style="color:#c0c5ce;">|     }
  |     - `x` dropped here </span><span style="color:#b48ead;">while</span><span style="color:#c0c5ce;"> still borrowed
</span><span style="color:#d08770;">7 </span><span style="color:#c0c5ce;">|     println!(&quot;</span><span style="color:#a3be8c;">r: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, r);
  |                       - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain </span><span style="color:#d08770;">E0597</span><span style="color:#c0c5ce;">`.
</span></code></pre>
<p>这里提示说<code>'x' does not live long enough</code>。<code>r</code>引用了一个存活不够久的 <code>x</code>。<code>r</code>的生命周期比<code>x</code>的生命周期长。</p>
<p>Rust 通过借用检查器（borrow checker）比较作用域来确保所有的引用都是有效的。</p>
<p>继续看下面的代码：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> string1 = String::from(&quot;</span><span style="color:#a3be8c;">abcd</span><span style="color:#c0c5ce;">&quot;);
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> string2 = &quot;</span><span style="color:#a3be8c;">xyz</span><span style="color:#c0c5ce;">&quot;;

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> result = </span><span style="color:#96b5b4;">longest</span><span style="color:#c0c5ce;">(string1.</span><span style="color:#96b5b4;">as_str</span><span style="color:#c0c5ce;">(), string2);
    println!(&quot;</span><span style="color:#a3be8c;">The longest string is </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, result);
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longest</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span style="color:#c0c5ce;">{
    </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> x.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">() &gt; y.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">() {
        x
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
        y
    }
}
</span></code></pre>
<p>编译错误：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">error[</span><span style="color:#d08770;">E0106</span><span style="color:#c0c5ce;">]: missing lifetime specifier
 --&gt; src/main.rs:</span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">:</span><span style="color:#d08770;">33
  </span><span style="color:#c0c5ce;">|
</span><span style="color:#d08770;">9 </span><span style="color:#c0c5ce;">| </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longest</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">) -&gt; &amp;</span><span style="color:#b48ead;">str </span><span style="color:#c0c5ce;">{
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function</span><span style="color:#b48ead;">&#39;s return type </span><span style="color:#c0c5ce;">contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
</span><span style="color:#d08770;">9 </span><span style="color:#c0c5ce;">| </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longest</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#b48ead;">&#39;a</span><span style="color:#c0c5ce;">&gt;(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">) -&gt; &amp;</span><span style="color:#b48ead;">&#39;a str </span><span style="color:#c0c5ce;">{
  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain </span><span style="color:#d08770;">E0106</span><span style="color:#c0c5ce;">`.
</span></code></pre>
<p>错误提示说，函数返回值包含借用值，但是签名未说明是借用了<code>x</code>还是<code>y</code>。同时给出了建议将函数签名改写成:</p>
<p><code>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str</code></p>
<p>实际上我们无法在编译期确定该函数到底返回<code>x</code>还是<code>y</code>，也无法知道传入参数（引用）的生命周期，这就导致编译器无法判定返回的引用是否有效。这就需要按照提示改写函数签名。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longest</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#b48ead;">&#39;a</span><span style="color:#c0c5ce;">&gt;(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">) -&gt; &amp;</span><span style="color:#b48ead;">&#39;a str </span><span style="color:#c0c5ce;">{
    </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> x.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">() &gt; y.</span><span style="color:#96b5b4;">len</span><span style="color:#c0c5ce;">() {
        x
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
        y
    }
}
</span></code></pre>
<p>现在函数签名表明对于生命周期 'a，函数会获取两个参数，他们都是与生命周期 'a 存在的一样长的字符串 slice。函数会返回一个同样也与生命周期 'a 存在的一样长的字符串 slice。这样Rust 的借用检查器就可以在编译期检查传给该函数的参数是否合法。</p>
<p>当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。因为我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。</p>
<p>如果结构体中使用引用，同样也需要手工标注生命周期。如下代码：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Debug)]
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Foo{
    </span><span style="color:#bf616a;">str</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">,
    </span><span style="color:#bf616a;">a </span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">,
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = Foo{</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;,a: </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">};
    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;,x);
}
</span></code></pre>
<p>同样会编译错误：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">error[</span><span style="color:#d08770;">E0106</span><span style="color:#c0c5ce;">]: missing lifetime specifier
 --&gt; src/main.rs:</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">:</span><span style="color:#d08770;">10
  </span><span style="color:#c0c5ce;">|
</span><span style="color:#d08770;">3 </span><span style="color:#c0c5ce;">|     </span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">,
  |          ^ expected named lifetime </span><span style="color:#bf616a;">parameter
  </span><span style="color:#c0c5ce;">|
help: consider introducing a named lifetime parameter
  |
</span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">| </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Foo&lt;</span><span style="color:#b48ead;">&#39;a</span><span style="color:#c0c5ce;">&gt;{
3 |     </span><span style="color:#bf616a;">str</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">,
  |

</span><span style="color:#bf616a;">error</span><span style="color:#c0c5ce;">: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
</span></code></pre>
<p>改写成带标记生命周期的形式：</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Debug)]
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Foo&lt;</span><span style="color:#b48ead;">&#39;a</span><span style="color:#c0c5ce;">&gt;{
    </span><span style="color:#bf616a;">str</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span style="color:#c0c5ce;">,
    </span><span style="color:#bf616a;">a </span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">,
}

</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(){
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = Foo{</span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">: &quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;,a: </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">};
    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span style="color:#c0c5ce;">&quot;,x);
}
</span></code></pre>
<p>保证编译器可以检查对比<code>x</code>结构体的生命周期与其成员<code>str</code>的生命周期，前者比后者小的时候，编译通过。</p>
<p>静态生命周期<code>'static</code>，其生命周期能够存活于整个程序期间。所有的字符串字面量值都是<code>'static</code>的。</p>
<p>好了就这些。</p>
<p>参考：
https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">2020-11-24</div>
        
        <div class="article-taxonomies">
            
                <ul class="article-categories">
                    
                    <li><a href="https://blog.zongwu233.com/categories/blog/">blog</a></li>
                    
                </ul>
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://blog.zongwu233.com/tags/rust/">#Rust</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/bian-cheng-yu-yan/">#编程语言</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/suo-you-quan/">#所有权</a></li>
                    
                    <li><a href="https://blog.zongwu233.com/tags/nei-cun-guan-li/">#内存管理</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                © zongwu&#x27;s blog 2015 - 2020<br>
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
